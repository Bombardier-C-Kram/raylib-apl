#!cd $dir && /usr/bin/dyalogscript $fileName
⎕io←1

Assert ← {⍺←'assertion failure' ⋄ 0∊⍵:⍺ ⎕SIGNAL 8 ⋄ shy←0}



⍝ Makes an importer that improves the ffi function creation syntax
∇ OutputFunc ← R (funcName types)
  (into from) ← ↓⍉↑Struct_to_INTO_FROM¨types
  (,'O') ⎕NA pathToBinary,'|',funcName,' P'⍴⍨2×≢types
  OutputFunc ← types∘{v←⍺⋄O {⎕←⎕se.Dyalog.Utils.display(⍴⍵)(≡⍵)v⋄⍵} funcs MapFuncs ⍵}
∇
⍝1: Outputting function tacitly is bad
⍝2: Outputting function is bad
⍝3: Why not on InitWindow? 0 arguments?

⍝]Create # .
⍝rl←link.raylib⋄rl.Init ('link/',⍨⊃1⎕NPARTS'')'./libtemp-c-raylib.so'

⍝ predefined C types
atomTypes ← ⍬
atomTypes ,←⊂ bool ← 'I1'
atomTypes ,←⊂ c    ← 'I1'
atomTypes ,←⊂ i    ← 'I4'
atomTypes ,←⊂ f    ← 'F4'
atomTypes ,←⊂ u    ← 'U4'
atomTypes ,←⊂ i1   ← 'I1'
atomTypes ,←⊂ u1   ← 'U1'
atomTypes ,←⊂ u8   ← 'U8'
atomTypes ,←⊂ ptr  ← ,'P'
atomTypes ,←⊂ f8   ← 'F8'
atomTypes ,←⊂ i8   ← 'I8'
atomTypes ,←⊂ u2   ← 'U2'
atomTypes←∪atomTypes
typeBL ← {⍵≡,'P':8 ⋄ ⍎⊃⌽⍵}¨atomTypes ⍝ BL = bytes length

lib ← '../libtemp-c-raylib.so'
pop push ← ↓⍉↑typeBL{
  _←'IF'⎕NA¨(lib,'|memcpy2 ')∘,¨('P <',⍵)('>',⍵,' P'),¨⊂' U8'

  O←F{ ⍝ pop value
    topRuntime-←1
    _←'Stack underflow' Assert 0≤topRuntime
    ptr←(topRuntime+1)⊃stack
    ⍺⍺ (⍬ ptr ⍵⍵)
  }⍺
  U←I{ ⍝ push value
    topRuntime+←1
    stack ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨⍳0⌈topRuntime-≢stack ⍝ Make sure stack always has enough space
    ptr←topRuntime⊃stack
    _←⍺⍺(ptr(,⊂⍵) ⍵⍵)
    ptr
  }⍺

  ⎕OR¨'OU' ⍝ pOp pUsh
}¨atomTypes


rlDir ← '../link/',⍨⊃1⎕NPARTS''
rl ← 0⎕Fix rlDir,'raylib.apln'
rl.Init rlDir⍬
structs ← ∪{⍵/⍨'⋄'=⊃∘⊃¨⍵}rl.(⍎¨⎕NL) ¯2
⎕NA 'I4 ',lib,'|GetStructSize I4'
'tempAlloc' ⎕NA 'P ',lib,'|MemAlloc U4'
'tempFree'  ⎕NA      lib,'|MemFree P'
BytesEachArg ← ⌈/ GetStructSize¨ ⎕IO-⍨⍳≢structs
names ← 1↓¨⊃¨structs
maxArgs ← 127 ⍝ The C specification says the maximum arguments for a function is 127
__arguments ← {tempAlloc BytesEachArg}¨⍳maxArgs
__struct_conversion_arguments ← ⍬ ⍝ ⍬ is a default, will be mutated later


_F ← {f←⍺⍺ ⋄ ⎕OR'f'}
MapFuncs ← {⍺≡⊃⍺:⍺∘⊢⍵ ⋄ ⍺∇¨⍵}

PtrToBytes ← {
  _←'fromU1'⎕NA lib,'|memcpy2 =U1[','] P U8',⍨⍕⍵
  fromU1(⍵⍴0)⍺⍵
}

⍝ --------------------------- ⍝
⍝ Handling signed string type ⍝
⍝ --------------------------- ⍝
atomTypes ,←⊂ str ← '=0C1'
({pop,←,⊂1⊃⍵}⊣{push,←,⊂2⊃⍵}) {
  ⍝ O1 I1
  _←'FI'⎕NA¨(lib,'|memcpy2 ')∘,¨,∘' U8'¨'>P P' 'P <P' ⍝ MA = Mid After. Means these convert to/from pointer. IF = Into From
  ⍝ O2 I2
  _←'AM'⎕NA¨(lib,'|strcpy2 ')∘,¨'>0C1 P' 'P <0C1' ⍝ MA = Mid After. Means these convert to/from pointer. IF = Into From

  O←F{ ⍝ pop value
    topRuntime-←1
    _←'Stack underflow' Assert 0≤topRuntime
    ptr←(topRuntime+1)⊃stack
    strPtr ← ⍺⍺ (⍬ ptr 8)
    ⍵⍵ (⍬ strPtr) ⍝ TODO memory leak here. Fix: (tempFree strPtr)⊢
  }A
  U←I{ ⍝ push value
    topRuntime+←1
    stack ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨⍳0⌈topRuntime-≢stack ⍝ Make sure stack always has enough space
    ptr←topRuntime⊃stack
    (⍕≢⊢)⍵:0 Assert⍨'Expected string, got: ',⍎⍵
    strPtr ← tempAlloc 1+≢⍵
    _←⍵⍵ (strPtr ⍵)
    _←⍺⍺ (ptr strPtr 8)
    ptr
  }M
  ⎕OR¨'OU' ⍝ pOp pUsh
}⍬

⍝ ---------------- ⍝
⍝ Stack operations ⍝
⍝ ---------------- ⍝
stack ← ⍬
topRuntime ← 0

Push ← {
  topRuntime+←1
  stack ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨⍳0⌈topRuntime-≢stack ⍝ Make sure stack always has enough space
  topRuntime⊃stack
}
Pop ← {
  topRuntime-←1
  _←'Stack underflow' Assert 0≤topRuntime
  (topRuntime+1)⊃stack
}

atomTypes,←names

({pop,←1⊃⍵}⊣{push,←2⊃⍵}) ↓⍉↑{
  name←'⋄'∘,⍣¯1⊃⍵
  cleaned ← {2≤≡⍵:'⋄'∘,⍣¯1⊃⍵⋄⍵}¨ 1↓⍵
  _←('Struct',name,' not cleaned properly') Assert ∧/2>≡¨cleaned
  args←' P'⍴⍨2×1+≢cleaned   ⍝ Includes result
  _←'IF'⎕NA¨(lib,'|',name,,∘args)¨'INTO' 'FROM'

  O←F{ ⍝ pop value
    i←atomTypes⍳⍵⍵
    _←⍺⍺ (Push¨i),⍨Pop⍬
    ⌽{⍵∘⊢⍬}¨⌽pop[i]
  }cleaned
  U←I{ ⍝ push value
    (name cleaned)←⍵⍵
    i←atomTypes⍳cleaned
    i≢⍥≢⍵:0 Assert⍨name,' ⍵≢≢',⍕≢i
    _←push[i] {⍺∘⊢⍵}¨⍵
    _←⍺⍺ (ptr←Push⍬),⌽Pop¨i
    ptr
  }name cleaned

  ⎕OR¨'OU'
}¨structs

Clean ← {2≤≡⍵:'⋄'∘,⍣¯1⊃⍵⋄⍵}¨
Map ← {(~(⊂⍵)∊atomTypes)∧'='≡⊃⍵: ,'P' ⋄ ⍵}¨
∇F←R (name t);bm;in;out
  'Func'⎕NA lib,'|',name,' P'⍴⍨2×≢t
  io←(atomTypes∊⍨Clean t)∧'='≡¨⊃¨t ⍝ In and out
  bm ← '>'≢¨⊃¨t ⍝ In or out mask, neither is impossible
  in ← Map Clean t/⍨bm
  out ← Map Clean 1↓¨t/⍨~bm
  F←(io bm in out){(io bm in out)←⍺⍺
    in≢⍥≢⍵:0 Assert⍨'Wrong amount of arguments given: ','≢≢⍵',⍨⍕≢in
    _←push[atomTypes⍳in] {⍺∘⊢⍵}¨⍥⌽⍵
    args ← bm
    (( bm)/args) ← Pop¨in
    ((~bm)/args) ← Push¨out
    Func ← ⍵⍵ ⍝ I tried simplifying out this assignment but was unsuccessful. ⎕OR with niladic functions is no joke.
    {1≡≢⍵:⊃⍵⋄⍵} {⍵∘⊢⍬}¨pop[atomTypes⍳out]⊣{⍬≡⍵:Func ⋄ Func⍵} args
  }(⎕OR'Func')
∇
GenImageColor ← R 'GenImageColorRetPtr' rl.(('>',Image) i i Color)
ExportImageAsCode ← R('ExportImageAsCodeRetPtr' rl.(('>',bool) Image str)) ⍝ image fileName ⍝ Export image as code file defining an array of bytes, returns true on success
InitWindow ← R('InitWindowRetPtr' (i i str)) ⍝ width height title                                                ⍝ Initialize window and OpenGL context
CloseWindow ← R('CloseWindowRetPtr' ⍬) ⍝                                                                   ⍝ Close window and unload OpenGL context
WindowShouldClose ← R('WindowShouldCloseRetPtr' (,⊂ ('>',bool) )) ⍝ Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
BeginDrawing ← R('BeginDrawingRetPtr' ⍬) ⍝                                                                   ⍝ Setup canvas (framebuffer) to start drawing
EndDrawing ← R('EndDrawingRetPtr' (⍬)) ⍝                                                                   ⍝ End canvas drawing and swap buffers (double buffering)

⎕←(5×5×4) PtrToBytes⍨ ⊃⎕←img← GenImageColor 5 5 (0 0 0 255)
⎕← ExportImageAsCode img 'SomeString.h'
InitWindow 200 220 'hello'
:while ~WindowShouldClose⍬
  BeginDrawing⍬
  EndDrawing⍬
:EndWhile
CloseWindow⍬
'Stack leaking' Assert 0=topRuntime
⎕off

⍝ // -------------------- //
⍝ // Stack operations end //
⍝ // -------------------- //

Struct_to_INTO_FROM ← {
  '<=>'∊⍨⊂⊃⍵: MakePushAndPop ,'P'
  (1≡≢⍴⍵)∧1≡≡⍵:  MakePushAndPop ⍵
  '⋄'≢⊃⊃⍵: 'INTERNAL ERROR: unhandled argument type' Assert 0⊣⎕se.Dyalog.Utils.display⍵
  types ← 1↓⍵
  ⍝                                 ┌┬┬┬┬─────Skip fill case──────┬┐    ┌┬──extra return pointer argument
  __struct_conversion_arguments ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨1+⍳0⌈(1+≢types)-≢__struct_conversion_arguments

  ⍝ TODO add argument type checking here.
  LALA ← { ⍝ PtrLeft, BracketsRight,⍨
    ∨/0≠≡¨⍵:,'P' ⍝ If struct has scalers, it's bad kinda, handle later (lists are good, incase of ptrs delete info and make it just be ptr )
    2>|≡⍵:⍵ ⍝ Don't affect strings.
    ⎕←⍵
    ,'P'
  } types

  fgi←⊃names⍳⊂ name←1↓⊃⍵ ⍝ Func Global Index

  (into from) ← ↓⍉↑Struct_to_INTO_FROM¨types
  ⍝TODO Into/From: _←'SET'⎕NA 'out ',pathToBinary,'|',name,'INTO P',⊃,/' ',¨strs ⍝ Make a GETer later
  (LALA)(funcs,⍨⊂Into _F⍬)
  (⊢_F⍬)(⊢_F⍬)
}

⍝TODO
⍝ Please be smart enough to implement equal-length conversion
D←{⎕←≡⍵⋄⍵}
⎕←Struct_to_INTO_FROM '=',⊂u8
⎕←Struct_to_INTO_FROM '=',u8 u8
⎕←Struct_to_INTO_FROM 'U8'
