#!cd $dir && /usr/bin/dyalogscript $fileName
⎕io←1

⍝]Create # .
⍝rl←link.raylib⋄rl.Init ('link/',⍨⊃1⎕NPARTS'')'./libtemp-c-raylib.so'

Assert ← {⍺←'assertion failure' ⋄ 0∊⍵:⍺ ⎕SIGNAL 8 ⋄ shy←0}

⍝ predefined C types
atomTypes ← 'F8' 'F4' (,'P'),,'IU'∘.,'1248'

typeBL ← {⍵≡,'P':8 ⋄ ⍎⊃⌽⍵}¨atomTypes ⍝ BL = bytes length

lib ← '../libtemp-c-raylib.so'
pop push ← ↓⍉↑typeBL{
  _←'IF'⎕NA¨(lib,'|memcpy2 ')∘,¨('P <',⍵)('>',⍵,' P'),¨⊂' U8'

  O←F{ ⍝ pop value
    topRuntime-←1
    _←'Stack underflow' Assert 0≤topRuntime
    ptr←(topRuntime+1)⊃stack
    ⍺⍺ (⍬ ptr ⍵⍵)
  }⍺
  U←I{ ⍝ push value
    topRuntime+←1
    stack ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨⍳0⌈topRuntime-≢stack ⍝ Make sure stack always has enough space
    ptr←topRuntime⊃stack
    _←⍺⍺(ptr(,⊂⍵) ⍵⍵)
    ptr
  }⍺

  ⎕OR¨'OU' ⍝ pOp pUsh
}¨atomTypes


rlDir ← '../link/',⍨⊃1⎕NPARTS''
rl ← 0⎕Fix rlDir,'raylib.apln'
rl.Init rlDir⍬
structs ← ∪{⍵/⍨'⋄'=⊃∘⊃¨⍵}rl.(⍎¨⎕NL) ¯2
⎕NA 'I4 ',lib,'|GetStructSize I4'
'tempAlloc' ⎕NA 'P ',lib,'|MemAlloc U4'
'tempFree'  ⎕NA      lib,'|MemFree P'
BytesEachArg ← ⌈/ GetStructSize¨ ⎕IO-⍨⍳≢structs
names ← 1↓¨⊃¨structs
maxArgs ← 127 ⍝ The C specification says the maximum arguments for a function is 127
__arguments ← {tempAlloc BytesEachArg}¨⍳maxArgs
__struct_conversion_arguments ← ⍬ ⍝ ⍬ is a default, will be mutated later


_F ← {f←⍺⍺ ⋄ ⎕OR'f'}
MapFuncs ← {⍺≡⊃⍺:⍺∘⊢⍵ ⋄ ⍺∇¨⍵}

PtrToBytes ← {
  _←'fromU1'⎕NA lib,'|memcpy2 =U1[','] P U8',⍨⍕⍵
  fromU1(⍵⍴0)⍺⍵
}

⍝ --------------------------- ⍝
⍝ Handling signed string type ⍝
⍝ --------------------------- ⍝
atomTypes ,←⊂ str ← '=0C1'
({pop,←,⊂1⊃⍵}⊣{push,←,⊂2⊃⍵}) {
  ⍝ O1 I1
  _←'FI'⎕NA¨(lib,'|memcpy2 ')∘,¨,∘' U8'¨'>P P' 'P <P' ⍝ MA = Mid After. Means these convert to/from pointer. IF = Into From
  ⍝ O2 I2
  _←'AM'⎕NA¨(lib,'|strcpy2 ')∘,¨'>0C1 P' 'P <0C1' ⍝ MA = Mid After. Means these convert to/from pointer. IF = Into From

  O←F{ ⍝ pop value
    topRuntime-←1
    _←'Stack underflow' Assert 0≤topRuntime
    ptr←(topRuntime+1)⊃stack
    strPtr ← ⍺⍺ (⍬ ptr 8)
    ⍵⍵ (⍬ strPtr) ⍝ TODO memory leak here. Fix: (tempFree strPtr)⊢
  }A
  U←I{ ⍝ push value
    topRuntime+←1
    stack ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨⍳0⌈topRuntime-≢stack ⍝ Make sure stack always has enough space
    ptr←topRuntime⊃stack
    (⍕≢⊢)⍵:0 Assert⍨'Expected string, got: ',⍎⍵
    strPtr ← tempAlloc 1+≢⍵
    _←⍵⍵ (strPtr ⍵)
    _←⍺⍺ (ptr strPtr 8)
    ptr
  }M
  ⎕OR¨'OU' ⍝ pOp pUsh
}⍬

⍝ ---------------- ⍝
⍝ Stack operations ⍝
⍝ ---------------- ⍝
stack ← ⍬
topRuntime ← 0

Push ← {
  topRuntime+←1
  stack ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨⍳0⌈topRuntime-≢stack ⍝ Make sure stack always has enough space
  topRuntime⊃stack
}
Pop ← {
  topRuntime-←1
  _←'Stack underflow' Assert 0≤topRuntime
  (topRuntime+1)⊃stack
}

atomTypes,←names

({pop,←1⊃⍵}⊣{push,←2⊃⍵}) ↓⍉↑{
  name←'⋄'∘,⍣¯1⊃⍵
  cleaned ← {2≤≡⍵:'⋄'∘,⍣¯1⊃⍵⋄⍵}¨ 1↓⍵
  _←('Struct ',name,' not cleaned properly') Assert ∧/2>≡¨cleaned
  args←' P'⍴⍨2×1+≢cleaned   ⍝ Includes result
  _←'IF'⎕NA¨(lib,'|',name,,∘args)¨'INTO' 'FROM'

  O←F{ ⍝ pop value
    i←atomTypes⍳⍵⍵
    _←⍺⍺ (Push¨i),⍨Pop⍬
    ⌽{⍵∘⊢⍬}¨⌽pop[i]
  }cleaned
  U←I{ ⍝ push value
    (name cleaned)←⍵⍵
    i←atomTypes⍳cleaned
    i≢⍥≢⍵:0 Assert⍨name,' ⍵≢≢',⍕≢i
    _←push[i] {⍺∘⊢⍵}¨⍵
    _←⍺⍺ (ptr←Push⍬),⌽Pop¨i
    ptr
  }name cleaned

  ⎕OR¨'OU'
}¨structs

Clean ← {2≤≡⍵:'⋄'∘,⍣¯1⊃⍵⋄⍵}¨
Map ← {(~(⊂⍵)∊atomTypes)∧'='≡⊃⍵: ,'P' ⋄ ⍵}¨
∇F←R (name t);bm;in;out
  'Func'⎕NA lib,'|',name,' P'⍴⍨2×≢t
  io←(atomTypes∊⍨Clean t)∧'='≡¨⊃¨t ⍝ In and out
  bm ← '>'≢¨⊃¨t ⍝ In or out mask, neither is impossible
  in ← Map Clean t/⍨bm
  out ← Map Clean 1↓¨t/⍨~bm
  F←(io bm in out){(io bm in out)←⍺⍺
    in≢⍥≢⍵:0 Assert⍨'Wrong amount of arguments given: ','≢≢⍵',⍨⍕≢in
    _←push[atomTypes⍳in] {⍺∘⊢⍵}¨⍥⌽⍵
    args ← bm
    (( bm)/args) ← Pop¨in
    ((~bm)/args) ← Push¨out
    Func ← ⍵⍵ ⍝ I tried simplifying out this assignment but was unsuccessful. ⎕OR with niladic functions is no joke.
    {1≡≢⍵:⊃⍵⋄⍵} {⍵∘⊢⍬}¨pop[atomTypes⍳out]⊣{⍬≡⍵:Func ⋄ Func⍵} args
  }(⎕OR'Func')
∇
GenImageColor ← R 'GenImageColorRetPtr' rl.(('>',Image) i i Color)
ExportImageAsCode ← R('ExportImageAsCodeRetPtr' rl.(('>',bool) Image str)) ⍝ image fileName ⍝ Export image as code file defining an array of bytes, returns true on success
InitWindow ← R('InitWindowRetPtr' (i i str)) ⍝ width height title                                                ⍝ Initialize window and OpenGL context
CloseWindow ← R('CloseWindowRetPtr' ⍬) ⍝                                                                   ⍝ Close window and unload OpenGL context
WindowShouldClose ← R('WindowShouldCloseRetPtr' (,⊂ ('>',bool) )) ⍝ Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
BeginDrawing ← R('BeginDrawingRetPtr' ⍬) ⍝                                                                   ⍝ Setup canvas (framebuffer) to start drawing
EndDrawing ← R('EndDrawingRetPtr' (⍬)) ⍝                                                                   ⍝ End canvas drawing and swap buffers (double buffering)

⎕←(5×5×4) PtrToBytes⍨ ⊃⎕←img← GenImageColor 5 5 (0 0 0 255)
⎕← ExportImageAsCode img 'SomeString.h'
InitWindow 200 220 'hello'
:while ~WindowShouldClose⍬
  BeginDrawing⍬
  EndDrawing⍬
:EndWhile
CloseWindow⍬
'Stack leaking' Assert 0=topRuntime
