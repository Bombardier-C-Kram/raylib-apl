#!cd $dir && /usr/bin/dyalogscript $fileName
⎕io←1

Assert ← {⍺←'assertion failure' ⋄ 0∊⍵:⍺ ⎕SIGNAL 8 ⋄ shy←0}



⍝ Makes an importer that improves the ffi function creation syntax
∇ OutputFunc ← R (funcName types)
  (into from) ← ↓⍉↑Struct_to_INTO_FROM¨types
  (,'O') ⎕NA pathToBinary,'|',funcName,' P'⍴⍨2×≢types
  OutputFunc ← types∘{v←⍺⋄O {⎕←⎕se.Dyalog.Utils.display(⍴⍵)(≡⍵)v⋄⍵} funcs MapFuncs ⍵}
∇
⍝1: Outputting function tacitly is bad
⍝2: Outputting function is bad
⍝3: Why not on InitWindow? 0 arguments?

⍝]Create # .
⍝rl←link.raylib⋄rl.Init ('link/',⍨⊃1⎕NPARTS'')'./libtemp-c-raylib.so'

⍝ predefined C types
atomTypes ← ⍬
atomTypes ,←⊂ bool ← 'I1'
atomTypes ,←⊂ c    ← 'I1'
atomTypes ,←⊂ i    ← 'I4'
atomTypes ,←⊂ f    ← 'F4'
atomTypes ,←⊂ u    ← 'U4'
atomTypes ,←⊂ i1   ← 'I1'
atomTypes ,←⊂ u1   ← 'U1'
atomTypes ,←⊂ u8   ← 'U8'
atomTypes ,←⊂ ptr  ← ,'P'
atomTypes ,←⊂ f8   ← 'F8'
atomTypes ,←⊂ i8   ← 'I8'
atomTypes ,←⊂ u2   ← 'U2'
atomTypes←∪atomTypes
typeBL ← {'P'=⍵:8⋄⍎⍵}¨⊃¨⌽¨atomTypes ⍝ BL = bytes length

lib ← '../libtemp-c-raylib.so'
pop push ← ↓⍉↑typeBL{
  _←'IF'⎕NA¨(lib,'|memcpy ')∘,¨('P <',⍵)('>',⍵,' P'),¨⊂' U8'

  O←F{ ⍝ pop value
    topRuntime-←1
    _←'Stack underflow' Assert 0≤topRuntime
    ptr←(topRuntime+1)⊃stack
    ⍺⍺ (⍬ ptr ⍵⍵)
  }⍺
  U←I{ ⍝ push value
    topRuntime+←1
    stack ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨⍳0⌈topRuntime-≢stack ⍝ Make sure stack always has enough space
    ptr←topRuntime⊃stack
    _←⍺⍺ (ptr (,⊂⍵) ⍵⍵)
    ptr
  }⍺

  ⎕OR¨'OU' ⍝ pOp pUsh
}¨atomTypes

ustr ← '=C1'
str  ← '=0C1'

rlDir ← '../link/',⍨⊃1⎕NPARTS''
rl ← 0⎕Fix rlDir,'raylib.apln'
rl.Init rlDir⍬
structs ← ∪{⍵/⍨'⋄'=⊃∘⊃¨⍵}rl.(⍎¨⎕NL) ¯2
⎕NA 'I4 ',lib,'|GetStructSize I4'
'tempAlloc' ⎕NA 'P ',lib,'|MemAlloc U4'
BytesEachArg ← ⌈/ GetStructSize¨ ⎕IO-⍨⍳≢structs
names ← 1↓¨⊃¨structs
maxArgs ← 127 ⍝ The C specification says the maximum arguments for a function is 127
__arguments ← {tempAlloc BytesEachArg}¨⍳maxArgs
__struct_conversion_arguments ← ⍬ ⍝ ⍬ is a default, will be mutated later


_F ← {f←⍺⍺ ⋄ ⎕OR'f'}
MapFuncs ← {⍺≡⊃⍺:⍺∘⊢⍵ ⋄ ⍺∇¨⍵}

PtrToBytes ← {
  _←'fromU1'⎕NA lib,'|memcpy =U1[','] P U8',⍨⍕⍵
  fromU1(⍵⍴0)⍺⍵
}

⍝ ---------------- ⍝
⍝ Stack operations ⍝
⍝ ---------------- ⍝
stack ← ⍬
topInit ← 0
topRuntime ← 0

IsString ← 1≡≢⍤⍴ ⍝ TODO test for characters

Push ← {
  topRuntime+←1
  stack ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨⍳0⌈topRuntime-≢stack ⍝ Make sure stack always has enough space
  topRuntime⊃stack
}
Pop ← {
  topRuntime-←1
  _←'Stack underflow' Assert 0≤topRuntime
  (topRuntime+1)⊃stack
}

⍝⎕← ('>',Ray) v2 Camera
atomTypes,←names


({pop,←1⊃⍵}⊣{push,←2⊃⍵}) ↓⍉↑{
  name←'⋄'∘,⍣¯1⊃⍵
  cleaned ← {2≤≡⍵:'⋄'∘,⍣¯1⊃⍵⋄⍵}¨ 1↓⍵
  _←('Struct',name,' not cleaned properly') Assert ∧/2>≡¨cleaned
  args←' P'⍴⍨2×1+≢cleaned   ⍝ Includes result
  _←'IF'⎕NA¨(lib,'|',name,,∘args)¨'INTO' 'FROM'

  O←F{ ⍝ pop value
    i←atomTypes⍳⍵⍵
    _←⍺⍺ (Push¨i),⍨Pop⍬
    ⌽{⍵∘⊢⍬}¨⌽pop[i]
  }cleaned
  U←I{ ⍝ push value
    i←atomTypes⍳⍵⍵
    i≢⍥≢⍵:0 Assert⍨'⍵≢≢',⍕≢i
    _←push[i] {⍺∘⊢⍵}¨⍵
    _←⍺⍺ (ptr←Push⍬),⌽Pop¨i
    ptr
  }cleaned

  ⎕OR¨'OU'
}¨structs

⎕NA lib,'|GenImageColorRetPtr P P P P'

(push⊃⍨atomTypes⍳⊂'Color')∘⊢ 0 0 0 255
(push⊃⍨atomTypes⍳⊂'I4')∘⊢5
(push⊃⍨atomTypes⍳⊂'I4')∘⊢5

GenImageColorRetPtr (Push⍬),Pop¨⍳3  ⍝(('>',Image) i i Color)

⎕←(5×5×4) PtrToBytes⍨ ⊃⎕← (pop⊃⍨atomTypes⍳⊂'Image')∘⊢⍬
'Stack leaking' Assert 0=topRuntime
⎕off

⍝ // -------------------- //
⍝ // Stack operations end //
⍝ // -------------------- //

Struct_to_INTO_FROM ← {
  '<=>'∊⍨⊂⊃⍵: MakePushAndPop ,'P'
  (1≡≢⍴⍵)∧1≡≡⍵:  MakePushAndPop ⍵
  '⋄'≢⊃⊃⍵: 'INTERNAL ERROR: unhandled argument type' Assert 0⊣⎕se.Dyalog.Utils.display⍵
  types ← 1↓⍵
  ⍝                                 ┌┬┬┬┬─────Skip fill case──────┬┐    ┌┬──extra return pointer argument
  __struct_conversion_arguments ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨1+⍳0⌈(1+≢types)-≢__struct_conversion_arguments

  ⍝ TODO add argument type checking here.
  LALA ← { ⍝ PtrLeft, BracketsRight,⍨
    ∨/0≠≡¨⍵:,'P' ⍝ If struct has scalers, it's bad kinda, handle later (lists are good, incase of ptrs delete info and make it just be ptr )
    2>|≡⍵:⍵ ⍝ Don't affect strings.
    ⎕←⍵
    ,'P'
  } types

  fgi←⊃names⍳⊂ name←1↓⊃⍵ ⍝ Func Global Index

  (into from) ← ↓⍉↑Struct_to_INTO_FROM¨types
  ⍝TODO Into/From: _←'SET'⎕NA 'out ',pathToBinary,'|',name,'INTO P',⊃,/' ',¨strs ⍝ Make a GETer later
  (LALA)(funcs,⍨⊂Into _F⍬)
  (⊢_F⍬)(⊢_F⍬)
}

⍝TODO
⍝ Please be smart enough to implement equal-length conversion
D←{⎕←≡⍵⋄⍵}
⎕←Struct_to_INTO_FROM '=',⊂u8
⎕←Struct_to_INTO_FROM '=',u8 u8
⎕←Struct_to_INTO_FROM 'U8'
