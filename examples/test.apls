#!cd $dir && /usr/bin/dyalogscript $fileName
⎕io←1

Assert ← {⍺←'assertion failure' ⋄ 0∊⍵:⍺ ⎕SIGNAL 8 ⋄ shy←0}



⍝ Makes an importer that improves the ffi function creation syntax
∇ OutputFunc ← R (funcName types)
  (into from) ← ↓⍉↑Struct_to_INTO_FROM¨types
  (,'O') ⎕NA pathToBinary,'|',funcName,' P'⍴⍨2×≢types
  OutputFunc ← types∘{v←⍺⋄O {⎕←⎕se.Dyalog.Utils.display(⍴⍵)(≡⍵)v⋄⍵} funcs MapFuncs ⍵}
∇
⍝1: Outputting function tacitly is bad
⍝2: Outputting function is bad
⍝3: Why not on InitWindow? 0 arguments?

⍝]Create # .
⍝rl←link.raylib⋄rl.Init ('link/',⍨⊃1⎕NPARTS'')'./libtemp-c-raylib.so'

⍝ predefined C types
atomTypes ← ⍬
atomTypes ,←⊂ bool ← 'I1'
atomTypes ,←⊂ c    ← 'I1'
atomTypes ,←⊂ i    ← 'I4'
atomTypes ,←⊂ f    ← 'F4'
atomTypes ,←⊂ u    ← 'U4'
atomTypes ,←⊂ i1   ← 'I1'
atomTypes ,←⊂ u1   ← 'U1'
atomTypes ,←⊂ u8   ← 'U8'
atomTypes ,←⊂ ptr  ← ,'P'
atomTypes ,←⊂ f8   ← 'F8'
atomTypes ,←⊂ i8   ← 'I8'
atomTypes ,←⊂ u2   ← 'U2'
atomTypes←∪atomTypes
typeBL ← {'P'=⍵:8⋄⍎⍵}¨⊃¨⌽¨atomTypes ⍝ BL = bytes length

lib ← '../libtemp-c-raylib.so'
pop push ← ↓⍉↑typeBL{
  _←'IF'⎕NA¨(lib,'|memcpy ')∘,¨('P <',⍵)('>',⍵,' P'),¨⊂' U8'

  H←F{ ⍝ pop value
    topRuntime-←1
    _←'Stack underflow' Assert 0≤topRuntime
    ptr←(topRuntime+1)⊃stack
    ⍺⍺ (⍬ ptr ⍵⍵)
  }⍺
  G←I{ ⍝ push value
    topRuntime+←1
    stack ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨⍳0⌈topRuntime-≢stack ⍝ Make sure stack always has enough space
    ptr←topRuntime⊃stack
    _←⍺⍺ (ptr (,⊂⍵) ⍵⍵)
    ptr
  }⍺

  ⎕OR¨'HG'
}¨atomTypes

ustr ← '=C1'
str  ← '=0C1'

rlDir ← '../link/',⍨⊃1⎕NPARTS''
rl ← 0⎕Fix rlDir,'raylib.apln'
rl.Init rlDir⍬
structs ← ∪{⍵/⍨'⋄'=⊃∘⊃¨⍵}rl.(⍎¨⎕NL) ¯2
⎕NA 'I4 ',lib,'|GetStructSize I4'
'tempAlloc' ⎕NA 'P ',lib,'|MemAlloc U4'
BytesEachArg ← ⌈/ GetStructSize¨ ⎕IO-⍨⍳≢structs
names ← 1↓¨⊃¨structs
maxArgs ← 127 ⍝ The C specification says the maximum arguments for a function is 127
__arguments ← {tempAlloc BytesEachArg}¨⍳maxArgs
__struct_conversion_arguments ← ⍬ ⍝ ⍬ is a default, will be mutated later


_F ← {f←⍺⍺ ⋄ ⎕OR'f'}
MapFuncs ← {⍺≡⊃⍺:⍺∘⊢⍵ ⋄ ⍺∇¨⍵}

PtrToBytes ← {
  _←'fromU1'⎕NA lib,'|memcpy =U1[','] P U8',⍨⍕⍵
  fromU1(⍵⍴0)⍺⍵
}

⍝ ---------------- ⍝
⍝ Stack operations ⍝
⍝ ---------------- ⍝
stack ← ⍬
topInit ← 0
topRuntime ← 0

IsString ← 1≡≢⍤⍴ ⍝ TODO test for characters

Push ← {
  topRuntime+←1
  stack ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨⍳0⌈topRuntime-≢stack ⍝ Make sure stack always has enough space
  topRuntime⊃stack
}
Pop ← {
  topRuntime-←1
  _←'Stack underflow' Assert 0≤topRuntime
  (topRuntime+1)⊃stack
}

⍝⎕← ('>',Ray) v2 Camera
intoFrom←{
  name←'⋄'∘,⍣¯1⊃⍵
  args←' P'⍴⍨2×≢⍵   ⍝ Includes result
  ⎕OR¨'AB'⎕NA¨ ⎕←(lib,'|',name,,∘args)¨'INTO' 'FROM'
}¨structs

⎕NA lib,'|Vector2INTO P P P'
⎕NA lib,'|Vector2FROM P P P'
⎕NA lib,'|Vector3INTO P P P P'
⎕NA lib,'|Vector3FROM P P P P'
⎕NA lib,'|RayINTO P P P'
⎕NA lib,'|RayFROM P P P'
⎕NA lib,'|ColorINTO P P P P P'
⎕NA lib,'|ColorFROM P P P P P'
⎕NA lib,'|GenImageColorRetPtr P I4 I4 P'
⎕NA lib,'|ImageINTO',' P'⍴⍨2×6
⎕NA lib,'|ImageFROM',' P'⍴⍨2×6

PushVector3 ← {
  _←'⍵≢≢3' Assert 3≡≢⍵
  _←pushF4∘⊢¨⍵
  Vector3INTO (Push⍬),pop¨⍵
}
PushColor ← {
  i←atomTypes⍳1↓rl.Color
  i≢⍥≢⍵:0 Assert⍨'⍵≢≢',⍕≢i
  _←push[i] {⍺∘⊢⍵}¨⍵
  ColorINTO (Push⍬),⌽Pop¨i
}
PushRay ← {
  _←'⍵≢≢2' Assert 2≡≢⍵
  PushVector3¨⍵
  RayINTO (Push⍬),pop¨⍵
}

PopImage ← {
  i←atomTypes⍳1↓rl.Image
  _←ImageFROM (Push¨i),⍨Pop⍬
  ⌽{⍵∘⊢⍬}¨⌽pop[i]
}

PushColor 0 0 0 255
GenImageColorRetPtr (Push⍬) 5 5 (Pop⍬)

⎕←(5×5×4) PtrToBytes⍨ ⊃⎕←PopImage⍬
⎕off

⍝ // -------------------- //
⍝ // Stack operations end //
⍝ // -------------------- //

Struct_to_INTO_FROM ← {
  '<=>'∊⍨⊂⊃⍵: MakePushAndPop ,'P'
  (1≡≢⍴⍵)∧1≡≡⍵:  MakePushAndPop ⍵
  '⋄'≢⊃⊃⍵: 'INTERNAL ERROR: unhandled argument type' Assert 0⊣⎕se.Dyalog.Utils.display⍵
  types ← 1↓⍵
  ⍝                                 ┌┬┬┬┬─────Skip fill case──────┬┐    ┌┬──extra return pointer argument
  __struct_conversion_arguments ,← {0≡⍵:0⋄tempAlloc BytesEachArg}¨1+⍳0⌈(1+≢types)-≢__struct_conversion_arguments

  ⍝ TODO add argument type checking here.
  LALA ← { ⍝ PtrLeft, BracketsRight,⍨
    ∨/0≠≡¨⍵:,'P' ⍝ If struct has scalers, it's bad kinda, handle later (lists are good, incase of ptrs delete info and make it just be ptr )
    2>|≡⍵:⍵ ⍝ Don't affect strings.
    ⎕←⍵
    ,'P'
  } types

  fgi←⊃names⍳⊂ name←1↓⊃⍵ ⍝ Func Global Index

  (into from) ← ↓⍉↑Struct_to_INTO_FROM¨types
  ⍝TODO Into/From: _←'SET'⎕NA 'out ',pathToBinary,'|',name,'INTO P',⊃,/' ',¨strs ⍝ Make a GETer later
  (LALA)(funcs,⍨⊂Into _F⍬)
  (⊢_F⍬)(⊢_F⍬)
}

⍝TODO
⍝ Please be smart enough to implement equal-length conversion
D←{⎕←≡⍵⋄⍵}
⎕←Struct_to_INTO_FROM '=',⊂u8
⎕←Struct_to_INTO_FROM '=',u8 u8
⎕←Struct_to_INTO_FROM 'U8'
